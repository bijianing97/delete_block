"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Receipt = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const log_1 = require("./log");
const extension_1 = require("./extension");
/**
 * Transaction receipt class
 */
class Receipt {
    constructor(cumulativeGasUsed, bitvector, logs, status) {
        this.cumulativeGasUsed = cumulativeGasUsed;
        this.bitvector = bitvector;
        this.logs = logs;
        this.status = status;
    }
    /**
     * Return the cumulative gas in `BN` type
     */
    get bnCumulativeGasUsed() {
        return new ethereumjs_util_1.BN(this.cumulativeGasUsed);
    }
    /**
     * Generate receipt object by given serialized data
     * @param serialized - Serialized data
     * @returns Receipt object
     */
    static fromRlpSerializedReceipt(serialized) {
        const values = ethereumjs_util_1.rlp.decode(serialized);
        if (!Array.isArray(values)) {
            throw new Error('Invalid serialized receipt input. Must be array');
        }
        return Receipt.fromValuesArray(values);
    }
    /**
     * Generate receipt object by given values
     * @param values - Values
     * @returns Receipt object
     */
    static fromValuesArray(values) {
        if (values.length !== 4) {
            throw new Error('Invalid receipt. Only expecting 4 values.');
        }
        const [status, cumulativeGasUsed, bitvector, rawLogs] = values;
        return new Receipt(cumulativeGasUsed, bitvector, rawLogs.map((rawLog) => log_1.Log.fromValuesArray(rawLog)), (0, ethereumjs_util_1.bufferToInt)(status) === 0 ? 0 : 1);
    }
    /**
     * Get the row data from receipt
     * @returns
     */
    raw() {
        return [(0, ethereumjs_util_1.unpadBuffer)((0, ethereumjs_util_1.toBuffer)(this.status)), this.cumulativeGasUsed, this.bitvector, this.logs.map((l) => l.raw())];
    }
    /**
     * Serialize data
     * @returns Encoded data
     */
    serialize() {
        return ethereumjs_util_1.rlp.encode(this.raw());
    }
    /**
     * Init extension
     */
    initExtension(block, tx, gasUsed, txIndex) {
        this.extension = new extension_1.ReceiptExtension(block, tx, gasUsed, txIndex);
        this.logs.forEach((log, i) => {
            log.initExtension(this.extension, i);
        });
    }
    /**
     * Convert receipt information to json format
     * @returns JSON format receipt
     */
    toRPCJSON() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return {
            blockHash: ((_a = this.extension) === null || _a === void 0 ? void 0 : _a.blockHash) ? (0, ethereumjs_util_1.bufferToHex)(this.extension.blockHash) : undefined,
            blockNumber: ((_b = this.extension) === null || _b === void 0 ? void 0 : _b.blockNumber) ? (0, ethereumjs_util_1.bnToHex)(this.extension.blockNumber) : undefined,
            contractAddress: ((_c = this.extension) === null || _c === void 0 ? void 0 : _c.contractAddress) ? (0, ethereumjs_util_1.bufferToHex)(this.extension.contractAddress) : null,
            cumulativeGasUsed: (0, ethereumjs_util_1.bnToHex)(this.bnCumulativeGasUsed),
            from: ((_d = this.extension) === null || _d === void 0 ? void 0 : _d.from) ? (0, ethereumjs_util_1.bufferToHex)(this.extension.from) : undefined,
            gasUsed: ((_e = this.extension) === null || _e === void 0 ? void 0 : _e.gasUsed) ? (0, ethereumjs_util_1.bnToHex)(this.extension.gasUsed) : undefined,
            logs: this.logs.map((log) => log.toRPCJSON()),
            logsBloom: (0, ethereumjs_util_1.bufferToHex)(this.bitvector),
            status: (0, ethereumjs_util_1.intToHex)(this.status),
            to: ((_f = this.extension) === null || _f === void 0 ? void 0 : _f.to) ? (0, ethereumjs_util_1.bufferToHex)(this.extension.to) : undefined,
            transactionHash: ((_g = this.extension) === null || _g === void 0 ? void 0 : _g.transactionHash) ? (0, ethereumjs_util_1.bufferToHex)(this.extension.transactionHash) : undefined,
            transactionIndex: ((_h = this.extension) === null || _h === void 0 ? void 0 : _h.transactionIndex) !== undefined ? (0, ethereumjs_util_1.intToHex)(this.extension.transactionIndex) : undefined
        };
    }
}
exports.Receipt = Receipt;
//# sourceMappingURL=receipt.js.map