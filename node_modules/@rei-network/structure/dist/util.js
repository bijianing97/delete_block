"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mustParseTransction = exports.calcIntrinsicGas = exports.calcTransactionTrie = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const merkle_patricia_tree_1 = require("merkle-patricia-tree");
const tx_1 = require("./tx");
/**
 * Calculate transaction trie
 * @param transactions - Transactions
 * @returns Transaction trie
 */
async function calcTransactionTrie(transactions) {
    const trie = new merkle_patricia_tree_1.BaseTrie();
    for (const [i, tx] of transactions.entries()) {
        await trie.put(ethereumjs_util_1.rlp.encode(i), tx.serialize());
    }
    return trie.root;
}
exports.calcTransactionTrie = calcTransactionTrie;
/**
 * Calculate intrinsic gas
 * @param isCreate - Is a contract creation transaction
 * @param data - Transaction data
 * @returns Intrinsic gas
 */
function calcIntrinsicGas(isCreate, data) {
    const gas = isCreate ? new ethereumjs_util_1.BN(53000) : new ethereumjs_util_1.BN(21000);
    const nz = new ethereumjs_util_1.BN(0);
    const z = new ethereumjs_util_1.BN(0);
    for (const b of data) {
        (b !== 0 ? nz : z).iaddn(1);
    }
    gas.iadd(nz.muln(16));
    gas.iadd(z.muln(4));
    return gas;
}
exports.calcIntrinsicGas = calcIntrinsicGas;
/**
 * Generate transaction object by given values
 * If transaction isn't `LegacyTransaction`, it will throw an error
 * @param values - Transaction values
 * @param opts - The options for initializing a Transaction.
 * @returns Transaction object
 */
function mustParseTransction(values, opts) {
    if (values.length === 6 || values.length === 9) {
        return tx_1.Transaction.fromValuesArray(values, opts);
    }
    throw new Error('invalid tx data');
}
exports.mustParseTransction = mustParseTransction;
//# sourceMappingURL=util.js.map