"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DBDeleteBloomBitsSectionCount = exports.DBSaveBloomBitsSectionCount = exports.DBSaveBloomBits = exports.DBSaveTxLookup = exports.DBSaveReceipts = exports.DBSaveLookups = exports.DBSetHashToNumber = exports.DBSetBlockOrHeader = exports.DBSetTD = exports.DBOp = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const structure_1 = require("@rei-network/structure");
const operation_1 = require("./operation");
Object.defineProperty(exports, "DBOp", { enumerable: true, get: function () { return operation_1.DBOp; } });
const constants_1 = require("./constants");
/*
 * This extra helper file serves as an interface between the blockchain API functionality
 * and the DB operations from `db/operation.ts` and also handles the right encoding of the keys
 */
function DBSetTD(TD, blockNumber, blockHash) {
    return operation_1.DBOp.set(operation_1.DBTarget.TotalDifficulty, ethereumjs_util_1.rlp.encode(TD), {
        blockNumber,
        blockHash
    });
}
exports.DBSetTD = DBSetTD;
/*
 * This method accepts either a BlockHeader or a Block and returns a list of DatabaseOperation instances
 *
 * - A "Set Header Operation" is always added
 * - A "Set Body Operation" is only added if the body is not empty (it has transactions/uncles) or if the block is the genesis block
 * (if there is a header but no block saved the DB will implicitly assume the block to be empty)
 */
function DBSetBlockOrHeader(blockBody) {
    const header = blockBody instanceof structure_1.Block ? blockBody.header : blockBody;
    const dbOps = [];
    const blockNumber = header.number;
    const blockHash = header.hash();
    const headerValue = header.serialize();
    dbOps.push(operation_1.DBOp.set(operation_1.DBTarget.Header, headerValue, {
        blockNumber,
        blockHash
    }));
    const isGenesis = header.number.eqn(0);
    if (isGenesis || (blockBody instanceof structure_1.Block && (blockBody.transactions.length || blockBody.uncleHeaders.length))) {
        const bodyValue = ethereumjs_util_1.rlp.encode(blockBody.raw().slice(1));
        dbOps.push(operation_1.DBOp.set(operation_1.DBTarget.Body, bodyValue, {
            blockNumber,
            blockHash
        }));
    }
    return dbOps;
}
exports.DBSetBlockOrHeader = DBSetBlockOrHeader;
function DBSetHashToNumber(blockHash, blockNumber) {
    const blockNumber8Byte = (0, constants_1.bufBE8)(blockNumber);
    return operation_1.DBOp.set(operation_1.DBTarget.HashToNumber, blockNumber8Byte, {
        blockHash
    });
}
exports.DBSetHashToNumber = DBSetHashToNumber;
function DBSaveLookups(blockHash, blockNumber) {
    const ops = [];
    ops.push(operation_1.DBOp.set(operation_1.DBTarget.NumberToHash, blockHash, { blockNumber }));
    const blockNumber8Bytes = (0, constants_1.bufBE8)(blockNumber);
    ops.push(operation_1.DBOp.set(operation_1.DBTarget.HashToNumber, blockNumber8Bytes, {
        blockHash
    }));
    return ops;
}
exports.DBSaveLookups = DBSaveLookups;
/**
 * Create Receipts operation for the given receipts
 * @param receipts - Target receipts
 * @param blockHash - Block hash
 * @param blockNumber - Block number
 * @returns New operation
 */
function DBSaveReceipts(receipts, blockHash, blockNumber) {
    return operation_1.DBOp.set(operation_1.DBTarget.Receipts, ethereumjs_util_1.rlp.encode(receipts.map((r) => r.raw())), {
        blockHash,
        blockNumber
    });
}
exports.DBSaveReceipts = DBSaveReceipts;
/**
 * Create TxLookup operations for all transactions of the given block
 * @param block - Target block
 * @returns Array of operations
 */
function DBSaveTxLookup(block) {
    const dbOps = [];
    const blockNumber = block.header.number;
    for (const tx of block.transactions) {
        dbOps.push(operation_1.DBOp.set(operation_1.DBTarget.TxLookup, (0, ethereumjs_util_1.toBuffer)(blockNumber), {
            txHash: tx.hash()
        }));
    }
    return dbOps;
}
exports.DBSaveTxLookup = DBSaveTxLookup;
/**
 * Create BloomBits operation for the given section
 * @param bit - Bit index of target section
 * @param section - Section number
 * @param hash - Hash of the last block header of the target section
 * @param bits - Bloom bits data
 * @returns New operation
 */
function DBSaveBloomBits(bit, section, hash, bits) {
    return operation_1.DBOp.set(operation_1.DBTarget.BloomBits, bits, { bit, section, hash });
}
exports.DBSaveBloomBits = DBSaveBloomBits;
/**
 * Create BloomBitsSectionCount operation
 * @param section - Section number
 * @returns  New operation
 */
function DBSaveBloomBitsSectionCount(section) {
    return operation_1.DBOp.set(operation_1.DBTarget.BloomBitsSectionCount, section.toString());
}
exports.DBSaveBloomBitsSectionCount = DBSaveBloomBitsSectionCount;
/**
 * Create a operation to delete BloomBitsSectionCount
 * @returns New operation
 */
function DBDeleteBloomBitsSectionCount() {
    return operation_1.DBOp.del(operation_1.DBTarget.BloomBitsSectionCount);
}
exports.DBDeleteBloomBitsSectionCount = DBDeleteBloomBitsSectionCount;
//# sourceMappingURL=helpers.js.map